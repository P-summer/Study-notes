```
<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>防抖与节流</title>
</head>

<body>
    <input id="debounce"></input>
    <button onclick="myFunction()">节流</button>
</body>
<script>
    //模拟一段ajax请求	防抖是将多次执行变为最后一次执行	节流是将多次执行变为在规定时间内只执行一次.一般不会重置定时器
    function ajax(content) {
        console.log('ajax request:' + content)
    }
    function debounce(fun, delay) {
        let timer = null
        return function (args) {
            let that = this
            let _args = args
            /* clearTimeout(fun.id)
            fun.id = setTimeout(function () {
                fun.call(that, _args)
            }, delay) */

            if (timer) clearTimeout(timer);
            timer = setTimeout(function () {
                fun.call(that, _args)
            }, delay)
        }
    }
    //接着用变量保存 debounce 返回的带有延时功能的函数
    let debounceAjax = debounce(ajax, 500)

    let inputEl = document.getElementById('debounce')
    inputEl.addEventListener('keyup', function (e) {
        debounceAjax(e.target.value)
    })

    function throttle(fun, delay) {
        let previous = 0;  //记录上一次触发的时间戳.这里初始设为0,是为了确保第一次触发产生回调
        let timer = null;
        return function (args) {
            let that = this;
            let _args = args;
            let now = Date.now(); //记录此刻触发时的时间戳
            let remaining = delay - (now - previous); //距离规定时间,还剩多少时间
            /* if (now - previous > delay) {  //如果时间差大于规定时间,则触发
                fun.call(that, _args);
                previous = now;
            } else {
                console.log('未冷却')
            } */

            /* if (!timer) {  //如果定时器不存在,则设置新的定时器,到时后,才执行回调,并将定时器设为null    第一次不会立即执行
                timer = setTimeout(function () {
                    timer = null;
                    fun.call(that, _args)
                }, delay)
            } else {
                console.log('未冷却')
            } */
            clearTimeout(timer);  //清除之前设置的定时器
            if (remaining <= 0) {
                fun.call(that, _args);
                previous = Date.now();
            } else {
                timer = setTimeout(function () {
                    fun.call(that, _args)
                }, remaining);//因为上面添加的clearTimeout.实际这个定时器只有最后一次才会执行
            }
        }
    }

    let throttleAjax = throttle(ajax, 2000)
    function myFunction() {
        throttleAjax("节流")
    }
</script>

</html>
```
