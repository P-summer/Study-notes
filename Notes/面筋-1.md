### 1.从浏览器输入URL到整个页面显示经历了什么？
1- 输入网址 → 2- 缓存解析 → 3- 域名解析 → 4- tcp连接，三次握手 → 5-服务器收到请求 6- 页面渲染 [here](https://segmentfault.com/a/1190000017184701),[another](https://github.com/i-want-offer/FE-Essay/blob/master/docs/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B.md)  
缓存就是把你之前访问的web资源，比如一些js，css，图片什么的保存在你本机的内存或者磁盘当中。在发送http之前，需要进行DNS解析即域名解析,DNS解析:域名到IP地址的转换过程。域名的解析工作由DNS服务器完成。解析后可以获取域名相应的IP地址  
在域名解析之后，浏览器向服务器发起了TCP的连接请求，三次握手建立tcp连接。TCP协议是面向连接的，所以在传输数据前必须建立连接  
（1）客户端A将标志位SYN置为1,随机产生一个值为seq=J（J的取值范围为=1234567）的数据包到服务器，客户端A进入SYN_SENT状态，等待服务端B确认  
（2）服务端B收到数据包后由标志位SYN=1知道客户端A请求建立连接，服务端B将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端A以确认连接请求，服务端B进入SYN_RCVD状态。(ACK报文)  
（3）客户端A收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务端B，服务端B检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端A和服务端B进入ESTABLISHED状态，完成三次握手，随后客户端A与服务端B之间可以开始传输数据了。  
三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。防止服务器接受失效请求；server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。主要目的防止server端一直等待，浪费资源。  
### 2.EventLoop？
Event Loop即事件循环，是指浏览器或Node的一种解决javaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理  
JavaScript单线程任务分为 __同步任务__ 和 __异步任务__。  
在JavaScript中，异步任务被分为两种，一种宏任务（MacroTask）也叫Task:script全部代码、setTimeout、setInterval
、I/O、UI Rendering。  
一种叫微任务（MicroTask：Promise、Process.nextTick（Node独有））；  
async/await在底层被转成了promise和then的回调函数，是promise的语法糖。  
区分微任务和宏任务是为了将异步队列任务划分优先级，通俗的理解就是为了插队  
Javascript 有一个 main thread 主线程和 call-stack 执行栈，__所有的任务都会被放到执行栈等待主线程执行。__  
存在微任务的话，那么就执行所有的微任务；微任务都执行完之后，执行下一个宏任务	以此循环  

执行栈在执行完同步任务后，查看执行栈是否为空，如果执行栈为空，就会去检查微任务(microTask)队列是否为空，如果为空的话，就执行Task（宏任务），否则就一次性执行完所有微任务。  
每次单个宏任务执行完毕后，检查微任务(microTask)队列是否为空，如果不为空的话，会按照先入先出的规则全部执行完微任务(microTask)后，设置微任务(microTask)队列为null，然后再执行宏任务，如此循环。
SYNC => MICRO => MACRO  
1）、同步和异步任务分别进入不同的执行"场所"，同步的进入主线程，异步的进入Event Table并注册函数  
2）、当指定的事情完成时，Event Table会将这个函数移入Event Queue。  
3）、主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。	Promise 新建后就会立即执行，then稍后。  
### 3.跨域问题及解决方式？
__什么是跨域：__ 在前端领域中，跨域是指浏览器允许向服务器发送跨域请求，从而克服Ajax只能同源使用的限制。  
__什么是同源策略：__ 同源策略是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。  


### 4.call、apply、bind 三者的区别？call 和 apply 哪个性能会好一些？如何实现 call、apply、bind？
区别主要提现在传参上，bind、apply、call 都是用来绑定函数执行时this的指向（改变函数执行时的上下文），同时还可以传参，调用它们的对象必须是一个函数 Function。call、apply可用于调用函数
```javascript
// call  
Function.call(obj, arg1, arg2, arg3, ...);

// apply，有两个参数，第二个是类数组
Function.apply(obj, [argArray]);

// bind，bind 方法的返回值是函数，需要手动调用才会执行，而 apply 和 call 则是立即调用
Function.bind(obj, arg1, arg2, arg3, ...);
```
```javascript
const obj = {
  name: '小鸭子',
};

function say (arg1, arg2) {
  console.log(`${this.name ? `我是一只${this.name}，` : ''}${arg1}，${arg2}`);
}

say('咿呀咿呀哟', '呱呱！'); // 咿呀咿呀哟，呱呱！
say.call(obj, '咿呀咿呀哟', '呱呱！') // 我是一只小鸭子，咿呀咿呀哟，呱呱！
say.apply(obj, ['咿呀咿呀哟', '呱呱！']); // 我是一只小鸭子，咿呀咿呀哟，呱呱！

const manualSay = say.bind(obj, '咿呀咿呀哟', '呱呱！'); // 绑定但不是立即执行
manualSay(); // 手动执行，输出：我是一只小鸭子，咿呀咿呀哟，呱呱！
```
**性能比较：** call 的性能要比 apply 好一些（尤其是传递给函数的参数超过三个的时候）。  [其他实现](https://leetoffer.com/question/608fbbb4a8cba06305b045f8)
```javascript
// 手写call，apply，bind之前考虑三个函数的区别及所做的事情
// 执行了函数，改变了函数的指向  在执行上下文上添加属性，指向函数，函数改变
Function.prototype.myCall = function(context) {
  context = context || window;
  const args = [...arguments].slice(1);
  context.fn = this; // 此时的this就是调用call的方法
  // 传null或者undefined，函数可以有返回值
  const result = context.fn(...args); // 调用方法，context调用了函数，this指向context
  delete context.fn;
  return result;
}

Function.prototype.myApply = function(context) {
  context = context || window;
  const args = arguments[1];
  context.fn = this;
  const result = args ? context.fn(...args) : context.fn();
  delete context.fn;
  return result;
}
// 返回一个函数，可以传参
Function.prototype.myBind = function(context) {
  context = context || window;
  const args = [...arguments].slice(1);
  const fn = this;
  return function() {
    return fn.apply(context,args);
  }
}
```
### 5.浏览器内存泄露的场景及如何解决？
**什么是内存泄漏** ：申请的内存没有及时回收掉，被泄漏了  
**为什么会发生内存泄漏** ：虽然前端有垃圾回收机制，但当某块无用的内存，却无法被垃圾回收机制认为是垃圾时，也就发生内存泄漏了.垃圾回收机制通常是使用标志清除策略  

__意外的全局变量__： 全局变量的生命周期最长，直到页面关闭前，它都存活着，所以全局变量上的内存一直都不会被回收.当全局变量使用不当，没有及时回收（手动赋值 null），或者拼写错误等将某个变量挂载到全局变量时，也就发生内存泄漏了。  
__定时器__： setTimeout 和 setInterval 是由浏览器专门线程来维护它的生命周期，所以当在某个页面使用了定时器，页面销毁时，没有手动去释放清理这些定时器的话，那么这些定时器还是存活着的。  
__使用不当的闭包__： 闭包可以维持函数内局部变量，使其得不到释放。  
__回调函数__： 定时器，事件监听器，Ajax请求，跨窗口通讯，Web Workers或者其他同步、异步任务，只要使用回调函数，实际上就是闭包。  
__循环引用__： eg:两个对象，互相引用对方。如果持续调用下面的函数，会导致内存不断升高。  
__DOM元素的引用__：DOM 元素的生命周期正常是取决于是否挂载在 DOM 树上，当从 DOM 树上移除时，也就可以被销毁回收了。但如果某个 DOM 元素，在 js 中也持有它的引用时，那么它的生命周期就由 js 和是否在 DOM 树上两者决定了，记得移除时，两个地方都需要去清理才能正常回收它。    
__控制台的打印__  


