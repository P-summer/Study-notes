## HTTP常用状态码
+ 200 OK,请求成功
+ 204 No Content，没有资源返回
+ 206 Partial Content，当从客户端发送Range范围标头以只请求资源的一部分时，将使用此响应代码
+ 301 Moved Permanently，请求资源的 URL 已永久更改。在响应中给出了新的 URL。
+ 302 Found，请求资源的 URI 已 暂时 更改
+ 303 See Other，指示客户端通过一个 GET 请求在另一个 URI 中获取所请求的资源
+ 304 Not Modified，它告诉客户端响应还没有被修改，因此客户端可以继续使用相同的缓存版本的响应
+ 307 Temporary Redirect，这与 302 Found HTTP 响应代码具有相同的语义，但用户代理 不能 更改所使用的 HTTP 方法：如果在第一个请求中使用了 POST，则在第二个请求中必须使用 POST
+ 400 Bad Request，由于被认为是客户端错误（例如，错误的请求语法、无效的请求消息帧或欺骗性的请求路由），服务器无法或不会处理请求。
+ 401 Unauthorized，客户端必须对自身进行身份验证才能获得请求的响应
+ 403 Forbidden，客户端没有访问内容的权限；与 401 Unauthorized 不同，服务器知道客户端的身份。
+ 404 Not Found，服务器找不到请求的资源。
+ 405 Method Not Allowed，服务器知道请求方法，但目标资源不支持该方法。
+ 500 Internal Server Error，服务器遇到了不知道如何处理的情况。
+ 502 Bad Gateway，该状态码表明扮演网关或代理角色的服务器，从上游服务器中接收到的响应是无效的
+ 503 Service Unavailable，服务器没有准备好处理请求。

## HTTP/0.9
不支持请求头 仅支持 Get 仅能访问 HTML 格式资源

## HTTP/1.0
+ 默认短连接（一次请求建议一次TCP连接，请求完就断开）,新增POST，DELETE，PUT，HEADER等方式
+ 增加请求头和响应头概念，指定协议版本号，携带其他元信息（状态码、权限、缓存、内容编码）
+ Content-Type 扩展传输内容格式（图片、音视频、二进制等都可以传输）
+ 
## HTTP/1.1
+ 新增  keep-alive 来让HTTP重用TCP链接，在一个 TCP 连接上可以传送多个 HTTP 请求，避免了因为多次建立 TCP 连接的时间消耗和延时(请求还是一个一个串行发的,存在队头阻塞问题)，__可以并发请求或者域名分片（二级域名）解决__
+ 支持pipeline网络传输(管道化连接)
+ HTTP/1.1 新增了 ETag、If-None-Match、If-Match 、If-Modified-Since 等新的请求头来控制缓存  cache control
+ HTTP/1.1 在请求头中引入了 Accept-Ranges，支持断点续传的功能
+ 在 HTTP/1.0 中认为每台服务器都有唯一的 IP 地址，但随着虚拟主机技术的发展，多个主机共享一个 IP 地址越发普遍，HTTP/1.1 的请求消息和响应消息都应该支持 __Host__ 头域，且请求消息中如果没有 Host 头域会报 400 错误
+ 正式加入了 __OPTIONS__ 方法，其主要用于 CORS – Cross Origin Resource Sharing 应用

## HTTP/2.0
### 头部压缩
采用了对应的压缩算法——HPACK，对请求头进行压缩。首先是在服务器和客户端之间建立哈希表，将用到的字段存放在这张表中，那么在传输的时候对于之前出现过的值，只需要把索引(比如0，1，2，...)传给对方即可，对方拿到索引查表就行了。这种传索引的方式，可以说让请求头字段得到极大程度的精简和复用。
### 多路复用
HTTP/2 从 HTTP 协议本身解决了队头阻塞问题。注意，这里并不是指的TCP队头阻塞，而是HTTP队头阻塞TCP 的队头阻塞是在数据包层面，单位是数据包，前一个报文没有收到便不会将后面收到的报文上传给 HTTP，而HTTP 的队头阻塞是在 HTTP 请求-响应层面，前一个请求没处理完，后面的请求就要阻塞住。两者所在的层次不一样。
#### 二进制分帧
HTTP/2 认为明文传输对机器而言太麻烦了，不方便计算机的解析,于是把报文全部换成二进制格式，全部传输01串，方便了机器的解析；原来Headers + Body的报文格式如今被拆分成了一个个二进制的帧，用Headers帧存放头部字段，Data帧存放请求体数据。  
分帧之后，服务器看到的不再是一个个完整的 HTTP 请求报文，而是一堆乱序的二进制帧。这些二进制帧不存在先后关系，因此也就不会排队等待，也就没有了 HTTP 的队头阻塞问题。
通信双方都可以给对方发送二进制帧，这种二进制帧的 __双向传输的序列__ ，也叫做流(Stream)。HTTP/2 用流来在一个 TCP 连接上来进行多个数据帧的通信，这就是多路复用的概念。
### 设置请求优先级
可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。
### 服务器推送
在 HTTP/2 当中，服务器已经不再是完全被动地接收请求，响应请求，它也能新建 stream 来给客户端发送消息，当 TCP 连接建立之后，比如浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中引用到的其他资源文件一起返回给客户端，减少客户端的等待。

## HTTPS
HTTPS 是 HTTP 协议的一种扩展,不是新的协议，使用传输层安全性(TLS)或安全套接字层(SSL)对通信协议进行加密。也就是 HTTP + SSL(TLS) = HTTPS。  
中间层进行加密：加密分为对称加密和非对称加密（耗时）
+ 用户在浏览器发起HTTPS请求（如 juejin.cn），默认使用服务端的443端口进行连接；
+ HTTPS需要使用一套CA数字证书，证书内会附带一个公钥Pub，而与之对应的私钥Private保留在服务端不公开；
+ 服务端收到请求，返回配置好的包含公钥Pub的证书给客户端；
+ 客户端收到证书，校验合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示HTTPS警告信息，如果通过则继续；
+ 客户端生成一个用于对称加密的随机Key，并用证书内的公钥Pub进行加密，发送给服务端；
+ 服务端收到随机Key的密文，使用与公钥Pub配对的私钥Private进行解密，得到客户端真正想发送的随机Key；
+ 服务端使用客户端发送过来的随机Key对要传输的HTTP数据进行对称加密，将密文返回客户端；
+ 客户端使用随机Key对称解密密文，得到HTTP数据明文；
+ 后续HTTPS请求使用之前交换好的随机Key进行对称加解密。

## UDP和TCP
+ UDP是一种面向报文的无连接的协议，不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式
+ 是一种面向连接的、可靠的、基于字节流的传输层通信协议
+ UDP丢包没有重发机制，TCP会判断丢包和重发
+ 头部开销小，传输数据报文时是很高效的，TCP头部开销较大

